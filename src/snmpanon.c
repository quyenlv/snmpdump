/*
 * snmpanon.c --
 *
 * A utility to anonymize SNMP messages in XML format (as generated by
 * snmpdump). The anonymized XML output will be written to stdout.
 *
 * (c) 2005-2006 Juergen Schoenwaelder <j.schoenwaelder@iu-bremen.de>
 *
 */

#include "config.h"

#include <string.h>
#include <unistd.h>
#include <inttypes.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <libxml/xmlmemory.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>

#include <smi.h>

#include "xpath-filter.h"
#include "libanon.h"

static const char *progname = "snmpanon";

static xmlDocPtr xml_doc;

static unsigned char my_key[32] = 
{
     21, 34, 23,141, 51,164,207,128, 19, 10, 91, 22, 73,144,125, 16,
    216,152,143,131,121,121,101, 39, 98, 87, 76, 45, 42,132, 34,  2
};

/*
 * Data structures used to describe the transformation instances we
 * keep and the rules which define when to apply these transformation
 * instances. We really should use a standard list, e.g. the xmllist
 * which comes with the libxml anyways...
 */

typedef struct transform {
    char *name;
    union {
	anon_ipv4_t   *an_ipv4;
	anon_ipv6_t   *an_ipv6;
	anon_mac_t    *an_mac;
	anon_int64_t  *an_int64;
	anon_uint64_t *an_uint64;
    } anon_union;
    /* range / size restrictions */
    /* options (lex) */
} transform_t;

typedef struct rule {
    char         *name;
    transform_t  *transform;
    char         *targets;
    xmlRegexpPtr target_regexp;
} rule_t;

static xmlListPtr transform_list = NULL;
static xmlListPtr rule_list = NULL;

/*
 *
 */

static void
mark_anon_ip_node(anon_ipv4_t *an_ip, const char *xpath, xmlXPathContextPtr ctxt)
{
    xmlXPathObjectPtr obj;
    xmlChar *content;
    int i;
    in_addr_t ip;

    fprintf(stderr, "** %s\n", __FUNCTION__);
    obj = xmlXPathEval(BAD_CAST(xpath), ctxt);
    fprintf(stderr, "** %s xmlXPathEval done\n", __FUNCTION__);
    if (obj) {
	if (obj->type == XPATH_NODESET) {
	    for (i = 0; i < xmlXPathNodeSetGetLength(obj->nodesetval); i++) {
		content = xmlNodeGetContent(obj->nodesetval->nodeTab[i]);
		if (inet_pton(AF_INET, (char *) content, &ip) > 0) {
		    anon_ipv4_set_used(an_ip, ip, 32);
		}
	    }
	}
	xmlXPathFreeObject(obj);
    }
}

static void
repl_anon_ip_node(anon_ipv4_t *an_ip, const char *xpath, xmlXPathContextPtr ctxt)
{
    xmlXPathObjectPtr obj;
    xmlChar *content;
    int i;
    in_addr_t ip;
    in_addr_t aip;

    obj = xmlXPathEval(BAD_CAST(xpath), ctxt);
    if (obj) {
	if (obj->type == XPATH_NODESET) {
	    for (i = 0; i < xmlXPathNodeSetGetLength(obj->nodesetval); i++) {
		content = xmlNodeGetContent(obj->nodesetval->nodeTab[i]);
		if (inet_pton(AF_INET, (char *) content, &ip) > 0) {
		    char buf[INET_ADDRSTRLEN];
		    (void) anon_ipv4_map_pref_lex(an_ip, ip, &aip);
		    if (inet_ntop(AF_INET, &aip, buf, sizeof(buf))) {
			xmlNodeSetContent(obj->nodesetval->nodeTab[i],
					  BAD_CAST(buf));
		    }
		}
	    }
	}
	xmlXPathFreeObject(obj);
    }
}

/*
 *
 */

static void
mark_anon_port_node(anon_int64_t *an_ip, const char *xpath, xmlXPathContextPtr ctxt)
{
    xmlXPathObjectPtr obj;
    xmlChar *content;
    int i;
    int64_t num;

    obj = xmlXPathEval(BAD_CAST(xpath), ctxt);
    if (obj) {
	if (obj->type == XPATH_NODESET) {
	    for (i = 0; i < xmlXPathNodeSetGetLength(obj->nodesetval); i++) {
		content = xmlNodeGetContent(obj->nodesetval->nodeTab[i]);
		if (sscanf((char *)content, "%"SCNd64, &num) == 1) {
		    anon_int64_set_used(an_ip, num);
		}
	    }
	}
	xmlXPathFreeObject(obj);
    }
}

static void
repl_anon_port_node(anon_int64_t *an_ip, const char *xpath, xmlXPathContextPtr ctxt)
{
    xmlXPathObjectPtr obj;
    xmlChar *content;
    int i;
    int64_t num, anum;

    obj = xmlXPathEval(BAD_CAST(xpath), ctxt);
    if (obj) {
	if (obj->type == XPATH_NODESET) {
	    for (i = 0; i < xmlXPathNodeSetGetLength(obj->nodesetval); i++) {
		content = xmlNodeGetContent(obj->nodesetval->nodeTab[i]);
                if (sscanf((char *)content, "%"SCNd64, &num) == 1) {
		    char buf[40];
		    (void) anon_int64_map_lex(an_ip, num, &anum);
		    if (snprintf(buf, sizeof(buf), "%"PRId64, anum) > 0) {
			xmlNodeSetContent(obj->nodesetval->nodeTab[i],
					  BAD_CAST(buf));
		    }
		}
	    }
	}
	xmlXPathFreeObject(obj);
    }
}

static void
mark_anon_varbind_name(const char *xpath, xmlXPathContextPtr ctxt)
{
    xmlXPathObjectPtr obj;
    xmlChar *content;
    SmiNode *smiNode;
    SmiType *smiType;
    int i;

    xmlNsPtr ns;
    ns = xmlNewNs(xml_doc->children, BAD_CAST("urn:foo:gaa:bar"), BAD_CAST("smi"));

    obj = xmlXPathEval(BAD_CAST(xpath), ctxt);
    if (obj) {
	if (obj->type == XPATH_NODESET) {
	    for (i = 0; i < xmlXPathNodeSetGetLength(obj->nodesetval); i++) {
		xmlNodePtr node = obj->nodesetval->nodeTab[i];
		content = xmlNodeGetContent(node);
		smiNode = smiGetNode(NULL, (char *) content);
		if (smiNode) {
		    if (smiNode->name) {
			xmlNewChild(node->parent, ns,
				    BAD_CAST("node"), BAD_CAST(smiNode->name));
		    }
		    smiType = smiGetNodeType(smiNode);
		    if (smiType && !smiType->name) {
			    smiType = smiGetParentType(smiType);
		    }
		    if (smiType && smiType->name) {
			xmlNewChild(node->parent, ns,
				    BAD_CAST("type"), BAD_CAST(smiType->name));
		    }
		}
	    }
	}
	xmlXPathFreeObject(obj);
    }

    /* xmlFreeNs(ns); */
}

/*
 * First anonymization transformation pass: collect all the data
 * values that need anonymization and clear the rest.
 */

static void
anon_pass1(anon_ipv4_t *an_ip, anon_int64_t *an_port)
{
    xmlXPathContextPtr ctxt;

    ctxt = xmlXPathNewContext(xml_doc);
    ctxt->node = xmlDocGetRootElement(xml_doc);

#if 0
    mark_anon_ip_node(an_ip, "/snmptrace/packet/*/@ip", ctxt);
    fprintf(stderr, "mark_anon_ip_node() done\n");
    mark_anon_port_node(an_port, "/snmptrace/packet/*/@port", ctxt);
    fprintf(stderr, "mark_anon_port_node() done\n");
#endif

    mark_anon_varbind_name("//snmptrace/packet/snmp/*/variable-bindings/varbind/name", ctxt);
    fprintf(stderr, "mark_anon_varbind_name() done\n");

    xmlXPathFreeContext(ctxt);
}

/*
 * Second anonymization transformation pass: replace the data
 * looking for anonymization.
 */

static void
anon_pass2(anon_ipv4_t *an_ip, anon_int64_t *an_port)
{
    xmlXPathContextPtr ctxt;

    ctxt = xmlXPathNewContext(xml_doc);
    ctxt->node = xmlDocGetRootElement(xml_doc);

#if 0
    repl_anon_ip_node(an_ip, "//snmptrace/packet/*/@ip", ctxt);
    repl_anon_port_node(an_port, "//snmptrace/packet/*/@port", ctxt);
#endif

    xmlXPathFreeContext(ctxt);
}

/*
 * Anonymize an XML document.
 */

static void
anonymize(xmlDocPtr xml_doc)
{
    anon_ipv4_t *an_ip;
    anon_int64_t *an_port;
    
    xmlXPathInit();
    
    an_ip = anon_ipv4_new();
    if (! an_ip) {
	fprintf(stderr, "%s: initialization of IP anonymization failed\n",
		progname);
	exit(1);
    }
    an_port = anon_int64_new(0, 65535);
    if (! an_port) {
	fprintf(stderr, "%s: initialization of port anonymization failed\n",
		progname);
	exit(1);
    }
    
    anon_ipv4_set_key(an_ip, my_key);
    anon_int64_set_key(an_port, my_key);
    
    anon_pass1(an_ip, an_port);	/* xml_root passed as global */
    anon_pass2(an_ip, an_port);	/* xml_root passed as global */
    
    anon_ipv4_delete(an_ip);
    anon_int64_delete(an_port);
   
}


int
main(int argc, char **argv)
{
    int i, c;
    xpath_filter_t *xpf;

    xpf = xpath_filter_new();

    transform_list = xmlListCreate(NULL, NULL);
    rule_list = xmlListCreate(NULL, NULL);

    smiInit(progname);
	
    while ((c = getopt(argc, argv, "Vha:c:d:m:")) != -1) {
	switch (c) {
	case 'a':
	    {
		rule_t *rule;

		rule = (rule_t *) malloc(sizeof(rule_t));
		if (! rule) {
		    /* xxx */
		    exit(1);
		}

		rule->name = "xx";
		rule->targets = optarg;
		rule->target_regexp = xmlRegexpCompile(BAD_CAST(optarg));
		if (!rule->target_regexp) {
		    /* xxx */
		    exit(1);
		}
		xmlListAppend(rule_list, rule);
	    }
	    break;
	case 'c':
	    if (xpf) {
		xpath_filter_add(xpf, BAD_CAST(optarg),
				 XPATH_FILTER_TYPE_CLEAR);
	    }
	    break;
	case 'd':
	    if (xpf) {
		xpath_filter_add(xpf, BAD_CAST(optarg),
				 XPATH_FILTER_TYPE_DELETE);
	    }
	    break;
	case 'm':
	    smiLoadModule(optarg);
	    break;
	case 's':
	    smiReadConfig(optarg, "snmpdump");
	    break;
	case 'V':
	    printf("%s %s\n", progname, VERSION);
	    exit(0);
	case 'h':
	case '?':
	    printf("%s [-a aexp] [-c xpath] [-d xpath] "
		   "[-m module] [-h] [-s config] file ... \n", progname);
	    exit(0);
	}
    }

    fprintf(stderr, "*** mib loading complete ***\n");

    if (optind == argc) {
	xml_doc = xmlReadFd(fileno(stdin), NULL, NULL, 0);
	if (! xml_doc) {
	    fprintf(stderr, "%s: could not parse XML from standard input\n", progname);
	    exit(1);
	}

	/* anonymize the data and apply any xpath filter */

	anonymize(xml_doc);
	xpath_filter_apply(xpf, xml_doc);

	/* print the resulting xml document */

	if (xmlDocFormatDump(stdout, xml_doc, 1) == -1) {
	    fprintf(stderr, "%s: failed to serialize xml document\n", progname);
	    exit(1);
	}
    }

    for (i = optind; i < argc; i++) {
	xml_doc = xmlReadFile(argv[i], NULL, 0);
	if (! xml_doc) {
	    fprintf(stderr, "%s: could not parse XML file '%s'\n",
		    progname, argv[i]);
	    continue;
	}

	fprintf(stderr, "*** file reading complete ***\n");

	/* anonymize the data and apply any xpath filter */

	anonymize(xml_doc);
	fprintf(stderr, "*** anonymization complete ***\n");
	xpath_filter_apply(xpf, xml_doc);
	fprintf(stderr, "*** filtering complete ***\n");

	/* print the resulting xml document */

	if (xmlDocFormatDump(stdout, xml_doc, 1) == -1) {
	    fprintf(stderr, "%s: failed to serialize xml document\n", progname);
	    exit(1);
	}
    }
    
    /* cleanup */

    xpath_filter_delete(xpf);

    return 0;
}
